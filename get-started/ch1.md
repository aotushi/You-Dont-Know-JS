# 你不知道的 JS: 入门 - 第 2 版

# 第一章: 什么*是*JavaScript?

你不知道的 JS. 我也不完全了解. 我们中没有人完全理解它. 但是我们可以开始更好的了解 JS.

在你不知道的 JS(YDKJSY)系列的第一本书的第一章中,我们将花些时间来构建基础并继续前进.我们需要从掌握很多重要背景管理细节开始,澄清关于关于这门语言是什么(和不是什么)的一些神话和误解.

这是对 JS 的身份和组织维护过程的宝贵洞见.所有的 JavaScript 开发者应该理解它.如果你想开始了解 JS,这就是如何*开始*旅程的第一步.

## 关于此书

我要强调的是旅程这个词因为*了解 JS*不是终点, 它是一个方向. 无论你在在这门语言上花费了多少时间, 你将总是能找到其它东西来学习和更好地理解. 所以不要把看这本书当做为了快速成就而匆匆完成的事情. 相反,耐心和坚持是你迈出最开始几步时最好的.

在背景章节以后,书籍剩余部分将会为你提供高标准的地图,当通过'你不知道的 JS'深入研究和学习 JS 时候你会发现什么.

尤其是第 4 章确定围绕 JS 语言组织的 3 大支柱: 作用域/闭包,原型/对象,和类型/强制转换. JS 是一门广泛和复杂的语言,拥有很多特性和功能.但是所有的 JS 都是建立在这 3 个基础支柱上的.

记住即使这本书被命名为'入门',它也不是准备作为初学者/入门的书.这本书的主要任务是做好准备来深入学习剩余系列的 JS; 它假设你已经熟悉 JS 至少几个月,在继续'你不知道的 JS'之前. 所以为了好好利用*入门*章节,确保你花足够多时间写 JS 代码来来构建经验.

即使之前您已经写了很多 JS,这本书不应该被略读或跳过; 花时间充分掌握这里的知识. **好的开始总是依赖于坚实的第一步**

## 关于那个名字是怎么回事?

JavaScript 这个名字可能是最被误解的编程语言名称.

这门语言和 Java 有关吗? 它只是 Java 的脚本形式吗?它是只用来写脚本和并非真正的编程语言吗?

事实是, JavaScript 这个名字是市场恶作剧的人为结果. 当 Brendan Eich 第一次构想出这门语言时, 他给它起了个 Mocha 的代号. 在 Netscape 内部, LiveScript 的品牌已经使. 但是当公开命名语言时, 'JavaScript'赢得了投票.

Why?因为这门语言本来被设计来吸引大多数 Java 程序员观众,并且因为'script'这个单词在那个时间是受欢迎的用来指向轻量级程序. 这些轻量级'scripts'将会是第一批插入被称为新事物的 web 上的东西.

换句话说,JavaScript 是种营销策略,旨在将这门语言定位为当时写更重更知名的 Java 的合适的替代品. 由于这个关系,它可以和容易的被称为'WebJava'.

在 JavaScript 的代码和 Java 代码之间有一些表面的相似. 这个相似性并非特别来自共享开发,而是来自两种语言,针对开发人员,他们假定语法期望来自 C(在某种程度上,C++).

举个例子, 我们用`{`开始代码块,`}`来结束代码块,就像 C/C++和 Java. 我们也用`;`来强调一个语句的结束;

在某种程度上,法规关系比语法更深.甲骨文(通过 Sun),依然掌控和运营 Java 的公司, 也掌控'JavaScript'这个名字的的商标.这个商标机会从未被执行过,而且很可能在这点上不可能执行.(?)

由于这些原因,一些人建议我们用 JS 代替 JavaScript. 这是一个非常通用的简写,如果不是一个正式语言品牌自身的良好候选者.实际上,书籍几乎只使用 JS 来代指这门语言.

进一步将语言和 Oracle 拥有的商标区分开发, TC39 指定并由 ECMA 标准机构正式确定的语言的正式名称是 **ECMAScript**。事实上,自从 2016 年开始,这个正式的语言名称也以修订年为后缀;在撰写本文时,是 ECMAScript2019,或者缩写为 ES2019.

换句话说,运行在你浏览器或 Node.js 中的 JavaScript/JS,是 ES2019 标准的一个实现.

| 笔记:                                                                                                                    |
| :----------------------------------------------------------------------------------------------------------------------- |
| 不要用例如'JS6'或'ES8'的术语代指这门语言. 已有部分人这样做了,这些称呼只会导致长期的困惑. 'ES20XX'或仅'JS'是你应该坚持的. |

无论是你称呼它为 JavaScript, JS, ECMAScript, 或 ES2019, 它绝对不是一 Java 语言的翻版.

> "Java 对于 JavaScript 就像 ham(火腿)对于 hamster(仓鼠)." --Jeremy Keith, 2009

## 语言规范 Language Specification

我提到的 TC39, 管理 JS 的技术指导委员会. 它们的首要任务是管理语言的官方规范.它们按时开会来为已经同意的更改进行投票, 它们将提交到 ECMA, 这个标准组织.

JS 的语法和行为在 ES 规范中定义.

ES2019 碰巧是第 10 个主要编号规范/修正自从 1995 年 JS 发布以来, 所以由 ECMA 托管的规范的官方 URL 中, 你将会找到'10.0'.

https://www.ecma-international.org/ecma-262/10.0/

TC39 委员会由 50 到大概 100 个来自广泛网络投资公司的人组成, 例如浏览器厂商(Mozilla,Google, Apple)和设备厂商(三星等). 委员会所有成员是志愿者, 尽管它们中的很多人是这些公司的员工,因此可能会因为在委员会职责而获得补偿.

TC39 会议通常是每隔一个月,通常为期大约三天,来回顾自上月来成员完成的工作,讨论问题,且对提案投票. 会议地点在愿意组织的会员间轮换.

所有的 TC39 提案都经过一个 5 个阶段的流程,因为我们是程序员,它是以 0 为基准,从阶段 0 到阶段 4.你可以在这里阅读更多的阶段过程: http://tc39.es/process-document/

阶段 0 大致意味着,TC39 的某人认为这是一个有价值的想法并且计划支持和实施它. 这意味着非 TC39 成员通过非正式手段例如社交媒体或发布的博客'提出'的想法实际上是'前阶段 0'. 你必须得到一个 TC39 成员来支持提案,为这个提案正式被定义为'阶段 0'.

一旦一个提案到达'阶段 4'状态, 它是合格的可被包含在下一年度的语言修订中.一项提案到发挥作用通过这几个阶段可能从几个月到几年.

所有的提案开放管理,在 TC39 的 github 仓库: https://github.com/tc39/proposals

任何人,无论在 TC39 还是不在,都被欢迎参与正在解决的提案的公共讨论和进程.然而,只有 TC39 成员能参加会议和在提案和变更上投票.所以在影响力上,一个 TC39 成员的声音在 JS 将走向哪里有很重的影响力.

和一些既定和让人沮丧的长存神话不同,世界上不存在多个版本的 JavaScript.仅仅有**一个 JavaScript**, TC39 和 ECMA 制定的官方标准.

早在 2000 年初,当微软维护一个分支并反向工程(且不完全兼容)称为'JScript'的 JS 的版本, 有合理的多个版本的 JS.但是这些日子已经远去.今天做出如此关于 JS 的声明是过时和不准确的.

所有的主流浏览器和设备制造商承诺让他们的 JS 应用遵循当前核心规范.当然,在引擎不同时期实现功能.与 SpiderMonkey 引擎(Mozilla 的引擎)相比,永远不会出现这种情况, v8 引擎(Chrome 的 JS 引擎)实现指定的特效的不同或不兼容

这意味着你可以学习**一种 JS**,并在任意地方依赖相同的 JS.

### 关于 JS 的网页规范的所有事情

虽然运行 JS 的环境在不断扩展(从浏览器,到服务器(Node.js),到机器人,到灯泡,到...),管理 JS 的环境是 web.换句话说,如何在 web 浏览器中实现 JS 是唯一重要的事情.

从绝大部分来说,在规范中定义的 JS 和运行在基于浏览器 JS 引擎中的 JS 是一样的.但是有些差异必须考虑到.

有时 JS 规范将强加一些新的或改进的行为,可是并不精确匹配在它基于浏览器 JS 引擎中的工作方式.这种不匹配是历史性的: JS 引擎有 20 多年观察行为,围绕功能的一些细节,这些细节已经被网络内容所依赖.正因为如此,有时 JS 引擎将拒绝遵照规范指示变化因为规范变化将破坏网页内容.

在这些案例中, TC39 经常出尔反尔和轻易选择使规范遵循网页的实际情况.举个例子, TC39 计划为数组添加一个`contains()`方法,但是发现这个名字和在一些网站上让在使用的旧 JS 框架相冲突,所以它们更改这个名字为不冲突的`includes()`. 同样的情况发生在一个被称为'smooshgate'的喜剧/悲剧 JS*社区危机*上, 计划`flatten()`方法最终被命名为`flat()`.

但是偶然情况下, TC39 也将决定规范在一些点上的坚持即使基于浏览器的 JS 引擎将不太符合.

解决方案? 附录 B, "为 web 浏览器新增的 ECMAScript 特性". [^specapb]]JS 规范包括这个附录到细节 详细说明官方 JS 规范和网页上真实 JS 间的任何已知不匹配. 换句话说, 这些是只被允许在 web JS 上的例外; 其它 JS 环境必须遵循规范的确切意义.

B.1 和 B.2 章节涵盖 web JS 包括的 JS(语法和 APIS)的*额外内容*, 又因为历史原因, 但是 TC39 不打算在核心 JS 中声明. 包括`0`前缀的 8 进制文本,全局`escape()`/`unescape()`工具, 字符串"helpers"例如`anchor()`和`blink()`, 和正则`compile()`方法.

B.3 章节包括一些冲突,其代码可能运行在 web 和非 webJS 引擎之间,但是其行为*可能*明显不同, 导致不同的输出. 大多数列举的更改都涉及在严格模式下运行时被标为早期的错误的情况.

附录 B*gotchas*不经常遇到,但为了未来安全起见,避免使用这些结构仍然是一个好主意.

### 不是所有的(WEB)JS...

这个代码是 JS 程序吗?

```js
alert("Hello, JS!");
```

取决于你如何看待这件事情. `alert()`函数在这里展示是不包含在 JS 规范中的,但是它在所有 web JS 环境中都有.至此,你将在附录 B 中不会找到它,所以发生了什么?

不同的 JS 环境(例如浏览器 JS 引擎,Node.js, 等等)添加 APIs 到你 JS 程序的全局作用域提供给你环境规范的兼容性,例如在用户浏览器中有能力弹出 alert-style 盒子.

事实上, 一系列看起来像 JS 的 APIs, 例如`fetch()`,`getCurrentLocation()`,和`getUserMedia()`,是看起来像 JS 的所有 web APIs. 在 Node.js 中,我们能从不同的内建模块,例如`fs.write()`是访问数百个 APIs 方法.

另一个常见的案例是`console.log()`(和所有其它的`console.*`方法). 这些方法在 JS 中并没有被明确声明,但是由于它们的全局功能被相当多的 JS 环境所定义,根据大致商定的共识.

所以`alert()`和`console.log()`不是被 JS 定义的.但是它们*看起来*像 JS. 它们是函数和对象方法并且它们遵循 JS 语法规则. 它们背后的行为被运行 JS 引擎的环境约束,但是在表面上它们必须明确遵循 JS 以能够在 JS 环境中使用.

大多数人抱怨的跨浏览器差异都与“JS 太不一致了！”有关，但实际上这些差异是由于这些环境行为的工作方式不同，而不是 JS 本身工作方式不同。

所以一个`alert()`调用是 JS,但是`alert()`自身实际上仅是一个客户,不是官方 JS 规范的一部分.

### 它并不总是 JS

在你的浏览器开发者工具(或 Node)使用 console/REPL(读取-评估-打印-循环)第一眼感觉像非常直接的 JS 环境.但是,实际上,它不是.

开发者工具是...提供给开发者的工具.它们首要的目的是让开发者的生涯更简单.它们优先考虑 DX(开发者经验).

顺便一提,这个便利是一件不错的事情.我高兴开发者工具让开发者生涯更轻松! 我高兴我们拥有漂亮 UX 体验,例如变量/属性的自动完成等. 我只是指出一点我们不能也不应该期望工具*总是*严格遵循 JS 程序被处理的方式, 因为这不是哪些工具的目的.

因为这种工具在浏览器到浏览器上行为的变化,并且因为它们的变化(有时而不是经常),我不准备'硬编码'任何规范细节到这篇文章, 所以确保了这本书文字不会迅速过期.

但是我只是暗示一些在不同 JS 控制环境中不同的点上真实的怪异案例, 以增强我的观点,当使用它们时不要假设原生 JS 行为:

-   '在控制台顶级'顶级作用域中,一个`var`或`function`声明是否实际创建一个真实的全局变量(和镜像`window`属性,反之亦然)

-   在顶级作用域中,多个`let`和`const`声明将会发生什么.

-   Whether `"use strict";` on one line-entry (pressing `<enter>` after) enables strict mode for the rest of that console session, the way it would on the first line of a .js file, as well as whether you can use `"use strict";` beyond the "first line" and still get strict mode turned on for that session.

-   非严格模式下`this`默认绑定如何用于函数调用, 并且是否'全局对象'用来包含预期的全局变量.

-   提升(见第二本书籍, 作用域&闭包)如何用于跨越多个行入口.

-   ...若干其它部分

开发者控制台不应该伪装成 JS 编译器,该编译器处理你输入的代码和 JS 引擎处理 a.js 文件完全相同. 它视图让你轻松快速输入若干行代码并迅速看到结果. 这些是完全不同的使用案例,因此,希望一个工具来公平处理两方面是不合理的.

不要信任你在开发者工具中看到的行为代表精确的 JS 语义.为此,请阅读规范,相反,将控制台视为 JS 友好的环境. 这本身就很有用.

## 多张面孔

在程序语言上下文中的术语'paradigm(范式)'代表广泛(几乎是全部)思维方式和构建代码的方法.在一个范式内,有无数的风格和形式的变化来区分程序,包括无数不同库和框架,它们在任何给定的代码上都留下了独特的印记.

但是无论一个程序的独特风格可能是什么,围绕范式的大局划分几乎总是在任何程序的第一眼就非常明显. (???)

典型的范式类别代码包括程序化,面向对象(OO/类),和函数化(FP):

-   过程式风格通过自上而下的线性进程组织代码,通过预先确定的一组操作,通常收集在被称为过程的相关单元中.

-   OO 风格通过收集逻辑和数据到称为类的单元中来组织代码

-   FP 风格组织代码到函数中(和过程对反的纯计算),并且这些函数改编为值.

范式没有正确和错误之分.它们是组织和塑造程序员如何解决问题和方案,如何构造和维护代码的方向.

一些语言着重倾向一种范式-C 是过程化的,Java/C++几乎全是面向类的,Haskell 是完全的 FP.

但是很多语言也支持来自,甚至混合和匹配不同范式的代码风格.所以称作'多范式'的语言提供基本的扩展性.在一些例子中,一个单独的程序甚至能用两个或多个并排在一起的范式表达式.

JavaScript 是最直接的多范式语言.你可以写过程化(procedural),面向类(class-oriented),或函数程序(FP)风格的代码,你能在逐行做出这些决定,而不是被迫做出全有或全屋的选择.

## 向后和向前

引导 JavaScript 的一个最基础的原则是保留向后兼容. 很多人对这个术语的含义感到困惑,并且也经常将其与一个相关但是不同的术语混淆: _向前兼容_.

让我们澄清事实.

向后兼容意味着过去的东西被作为合法 JS 被接受,未来语言的任何更改都不会导致该代码成为无效 JS.在 1995 年写的代码-无论多么原始或有限,今天应该仍然有效.就像 TC39 成员经常宣称的那样,"我们不会破坏网页!"

这个想法是 JS 开发者可以带着自信写代码,他们的代码不会因为发布的浏览器更新而不可预测停止工作.这使得为程序选择 JS 在未来几年是更安全和明智的投资

这个'保证'不是一件小事情.维持向后兼容,跨越了这门语言几乎 25 年的历史,带来了巨大的负担和一系列独特的挑战. 你很难找到很多其它案例, 在计算这种向后兼容的承诺时.

坚持这个方案的花费不应该被轻易推卸(dismiss). 它必然创建一个高标准来为包含更改或扩展这门语言;任何决定(错误和所有的)都会永久有效.一旦这种情况出现在 JS 中,它不能被移出因为它可能破坏程序,即使我们真想真想移除它.

对这个规则来说有一些小例外. JS 曾有一些向后不兼容变化,但是 TC39 在这样做时非常小心.他们研究 web 上的代码(通过浏览器数据收集)来评估这种故障的影响,并且浏览器厂商最终决定并投票他们是否愿意为一个小规模的故障而承担用户的压力,相比之下修复或改进语言的某些方面为更多的网站(和用户)的受益.

这种类型的变化不多,并且几乎总是在很多网站中不太可能被观察到的稀少案例用法.

将_向后兼容_与它对应物_向前兼容_比较.向前兼容意味着语言包含一个新增,在程序中不会导致故障即使运行在比较旧的JS引擎中. **JS不是向前兼容的**,尽管很多人希望如此,甚至错误的相信它就是的神话.

与之相比,HTML和CSS是向前兼容但不是向后兼容.如果你挖掘在1995年写的一些HTML和CSS,它可能有可能在今天不起作用(或者一样工作). 但是,如果你在浏览器中使用2010到2019年的新特性,这个页面不会'故障'--这些未识别的CSS/HTML将会略过,而剩下的CSS/HTML将被相应处理.

在程序语言设计中包含向前兼容看起来让人满意,但是这样做通常不实用. 标签(HTML)和样式(CSS)本质上是声明式的,所以它很容易'跳过'无法识别的声明,对其它已识别的声明影响最小.

如果一个编程语言选择性的跳过它不理解的声明(或甚至是表达式)就会出现混乱和不确定性,因为不可能确保程序的后续部分不需要跳过的部分进行处理.

尽管JS不是,也不可能是向前兼容的,但需要充分认识到JS的向后兼容,包含对网页持续的好处和作为结果强加给JS的限制和困难.

### 跳过差距

既然JS不是向前兼容的,它就意味着在你写的合法JS和你网站或应用需要支持的最老的引擎之间总会有间隔. 如果你在2016年的引擎中使用ES2019特征运行程序, 你很有可能看到程序故障和崩溃.

如果这个特征是新语法,程序在编译和执行上会整体失败,通常抛出一个语法错误.如果这个特征是一个API(例如,ES6的`Object.is()`),程序可能运行到某个点随后抛出一个运行时异常,并在遇到未知API引用时停止.

这意味着JS开发者应该总是落后于进步的步伐, 只使用它们需要支持的最老JS引擎环境最后边缘的代码?不行!

但是它的确意味着JS开发者需要特别注意解决这个差距.

对新的且不适配的语法,解决方法是转译. 转译是一个人为和社区发明的术语,用来描述使用工具将程序源代码从一种形式到另一种形式(但是依然作为文本源码).通常,与语法相关向前兼容的问题通过使用转译器(最普遍的是Babel(https://babeljs.io))从新的JS语法版本转换为等效旧的语法来解决.

例如,开发者可能写这样的代码片段:

```js
if (something) {
    let x = 3;
    console.log(x);
} else {
    let x = 4;
    console.log(x);
}
```

这是应用程序的源码树中,这段代码的样子如下:

```js
var x$0, x$1;
if (something) {
    x$0 = 3;
    console.log(x$0);
} else {
    x$1 = 4;
    console.log(x$1);
}
```

最初的片段依赖于`let`来在`if`和`else`句子中创建块作用域的`x`变量,它们不会相互干扰. Babel能生成一个等效的程序(具有最小的重新工作),只是选择用不同的名称命名两个不同的变量,产生相同的非干扰的输出.

| 笔记:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `let`关键字在ES6(2015)中被添加.前面的转译案例只需要在应用程序需要在不支持ES6的JS环境中运行的情况下应用.这里的简单案例仅仅为简单说明.当ES6还是新标准,这种转译的需求是非常盛行的,但是在2020年需要支持非ES6环境是不常见的. 编译使用的'目标'是一个滑动窗口,只有在为某个网站/应用程序决定停止支持某个旧浏览器/引擎时才向上滑动.

你可能好奇:为什么这么麻烦使用工具来将新语法版本转换为旧版本?我们不能仅仅写着两个变量并跳过使用`let`关键字吗?原因是,开发者被强烈推荐使用JS最新版本所以它们代码是干净且能最大效率交流想法

开发者应该聚焦在写干净的新语法形式,让工具考虑生成该代码的向前兼容版本,该版本适合在最旧的支持JS引擎环境中部署和运行.

### 填补差距(Filling the Gaps)

如果向前兼容问题与新语法不相关,而是与只是最近添加的缺失API有关. 最通常的解决方案是为缺失API方法提供定义,它会扮演和老环境中已经原生定义过一样.这种模式被称为polyfill(别名'shim')

考虑这块代码:

```js
// getSomeRecords() returns us a promise for some
// data it will fetch
var pr = getSomeRecords();

// show the UI spinner while we get the data
startSpinner();

pr.then(renderRecords) // render if successful
    .catch(showError) // show an error if not
    .finally(hideSpinner); // always hide the spinner
```

这块代码使用ES2019的特征,promise原型上的`finally()`方法.如果代码在前ES2019环境中使用,`finally()`方法将不会存在,并且将发生一个错误.

在前ES2019环境中`finally()`方法的polyfill可能看起来是这样的:

```js
if (!Promise.prototype.finally) {
    Promise.prototype.finally = function f(fn) {
        return this.then(
            function t(v) {
                return Promise.resolve(fn()).then(function t() {
                    return v;
                });
            },
            function c(e) {
                return Promise.resolve(fn()).then(function t() {
                    throw e;
                });
            }
        );
    };
}
```

| 警告:                                                                                                                                                                                                                                                      |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 这只是“final（..） 的基本（不完全符合规范）polyfill 的简单说明`. 不要在你的代码中使用这个polyfill; 无论在哪里总是使用健壮,正式的polyfill, 就像在ES-Shim中polyfill/shims的集合. |

`if`语句通过阻止polyfill在JS引擎已经定义其方法的环境中执行,来保护polyfill定义.在旧环境中, polyfill已经定义,但在新环境中`if`语句会安静的跳过.

像Babel之类的编译器通常会检测你的代码需要的polyfills并且自动提供给你. 但是偶然情况下你可能需要精确的包含/定义它们, 与我们刚看过的snippet的作用类似.

始终以最合适的特点来编写代码,以有效传达意图和目的.通常来说,这意味着使用最稳定的JS版本. 通过尝试手动适应语法/api差距以避免影响代码的可读性. 这就是工具的目的.

转译器和补丁是两个最有效的技术来解决使用语言的最新稳定特征和旧环境中网站或应用需要依然支持代码之间的代沟.因为JS不会停止发展,代沟也不会消失.两种技术应该作为每个JS项目生产链的标准部分.

## 解析器中是什么?

在JS中编写代码的长期问题是: 它是一个解释节本或者是编译程序?主流的意见看起来JS是一种解释(脚本)语言.但是事实比这个复杂.

在编程语言的大多数历史情况中,'解释型'语言和'脚本型'语言在与编译型语言相比,一直被视为劣等. 这种态度的原因很多,包括缺少性能优化的感觉,以及不喜欢某些语言特性,例如脚本语言通常使用动态语言类型而不是更成熟的静态类型语言.

被认为是'编译型'的语言通常生成程序的可移植(二进制)表现形式,该表现形式被分发以供以后执行.因为我们不能实际上观察到JS的这种模式(我们分发源代码,而不是二进制形式), 很多人声称从目录中取消JS的资格. 实际上,程序的'可执行'形式的分发模型已经变得非常多样化,而且相关性也变得越来越低.对于手头上的问题,传递什么形式的程序已经不再重要.

这些错误的主张和批评应该被置于一边. 清楚了解JS是解释还是编译的真正原因与处理错误的方式有关。

Historically, scripted or interpreted languages were executed in generally a top-down and line-by-line fashion; there's typically not an initial pass through the program to process it before execution begins (see Figure 1).
从历史上看，脚本或解释性语言通常以自上而下和逐行的方式执行;在执行开始之前，通常不会通过进程进行初始传递来处理它（参见图 1）。

<figure>
    <img src="images/fig1.png" width="650" alt="Interpreting a script to execute it" align="center">
    <figcaption><em>Fig. 1: Interpreted/Scripted Execution</em></figcaption>
    <br><br>
</figure>

在脚本或解释型语言中,程序中第5行的错误将不会被发现知道前4行被执行.记住,第5行的错误可能因为运行时条件,例如变量或值有一个对执行来说不合适的值,或者它可能改行不合法生命/命令.根据上下文,将错误处理延迟到发生错误的行可能是可取的,也可能是不可取的.

将其与在执行任何执行之前经历处理步骤（通常称为解析）的语言进行比较，如图 2 所示：

<figure>
    <img src="images/fig2.png" width="650" alt="Parsing, compiling, and executing a program" align="center">
    <figcaption><em>Fig. 2: Parsing + Compilation + Execution</em></figcaption>
    <br><br>
</figure>

在这个进行模型中,在解析阶段,第5行上一个不合法命令(例如破坏性语法)将会被捕获,在任意执行开始之前,程序不会执行.对于捕获语法错误(或其它'静态')错误,通常最好在任何注定要失败的执行之前了解它们.

解析语言与编译型语言有什么共同点?第一,所有编译型语言都是解析的.所以一个解析型语言距离编译型语言还有很长的路要走.在经典编译理论中,在解析后最后保留的步骤是代码生成: 生成可执行形式.

Once any source program has been fully parsed, it's very common that its subsequent execution will, in some form or fashion, include a translation from the parsed form of the program—usually called an Abstract Syntax Tree (AST)—to that executable form.
一旦任意源代码被完全解析,普遍的是它随后的执行,以一些形式,包括从称作抽象语法树(AST)的解析形式到执行形式的翻译.

换句话说,解析型语言通常在执行前也执行代码生成,所以好不夸张的说,在精神上,它们是编译型语言.

JS源代码在执行前会被解析. 该规范要求同样多，因为它要求在代码开始执行之前报告“早期错误”，即代码中静态确定的错误，例如重复的参数名称。如果代码未被解析，则无法识别这些错误。

所以**JS是解析型语言**, 但是它也是_编译型_吗?

答案比不是更接近是. 解析的JS转换为优化(二进制)形式,并且代码随后执行(Figure 2); 引擎在完成所有艰苦的解析工作后,通常不会切换回逐行执行(例如Figure 1)模式, 大多数语言/引擎不会,因为那样效率非常低.

具体来说, 编译会生成二进制代码,其之后会被交给'JS虚拟机'来执行. 一些人喜欢说这个虚拟机会'解析'字节码.但是那也就意味着Java,和其它JVM驱动的语言,由于这个关系,是解析型而不是编译型. 当然, 这与 Java/etc 是编译语言的典型断言相矛盾。

有意思的是, Java和JS是不同的语言,解释型/编译型的问题在它们之间是非常接近的.

另一个问题是,JS引擎可以对生成的代码(后解析)进行多次JIT(即时)处理/优化,根据不同角度,这同样可以合理地标记为'编译'或'解释'. 在JS引擎的引擎盖下,这实际上是一个非常复杂的情况.

那么这些细节归结为什么呢?退后一步,考虑一下JS源进程的整个流程:

1. 编写完程序之后,通过Babel转译,之后通过Webpack打包(可能还有其它6个进程),然后以不同形式分发到JS引擎.

2. JS引擎解析代码为AST.

3. 之后引擎转换AST为一种字节码, 二进制中间表示(IR), 之后被优化的JIT编译器进一步优化/转换.

4. 最后, JS虚拟机执行程序.

视觉化以上步骤:

<figure>
    <img src="images/fig3.png" width="650" alt="Steps of JS compilation and execution" align="center">
    <figcaption><em>Fig. 3: Parsing, Compiling, and Executing JS</em></figcaption>
    <br><br>
</figure>

JS处理模式像是一个逐行解释脚本,如图1,或者它的处理模型像编译语言,在执行前(像是图2,3)中进行1对多处理?

我认为很明显，在精神上，如果不在实践中，**JS 是一种编译型语言**。

And again, the reason that matters is, since JS is compiled, we are informed of static errors (such as malformed syntax) before our code is executed. That is a substantively different interaction model than we get with traditional "scripting" programs, and arguably more helpful!
此外,有关的原因是,既然JS是编译的,我们会在代码执行前被通知静态错误(例如非法格式的语法). 

### Web汇编 (WASM)

推动 JS 大量发展的一个主要问题是性能，包括 JS 的解析 / 编译速度以及编译后的代码的执行速度。

在2013年, Mozilla Firefox浏览器引擎演示虚幻 3 游戏引擎从 C 到 JS 的移植.运行在浏览器JS引擎中的代码以60fps性能预示JS引擎可以执行特性优化的能力,因为虚幻引擎使用的代码样式偏向于名为'ASM.js'的风格代码.

这个子集是有效的JS,其编写方式在正常编码中有些不常见,但是它向引擎发出某些重要的类型信息信号,允许它进行关键优化.ASM.js的引入是解决JS运行时性能压力的一种方式.

需要记住的是ASM.js从来不打算被开发者编码,而是从另一种语言(例如C)转译而来的进程表示形式,这些输入的注释会被工具自动插入.

在ASM.js证明了被工具创建的程序版本可以被JS引擎执行的更有效率, 另一组工程师（最初也来自 Mozilla）发布了 Web Assembly （WASM）。

在提供一个路径为非JS程序(例如C)转换为能在JS引擎中运行的形式上,WASM与ASM.js的目的是相似的.不像ASM.js,WASM选择绕过在程序执行前JS解析/编译的继承延迟,通过使用一种完全不像JS的程序形式.

WASM是一种更接近汇编的表示形式,跳过JS引擎平常做的解析/编译来执行的. 解析/编译WASM向的程序在(AOT)时间之前; 分发二进制包程序来为JS引擎执行最小进程.

WASM最初的动机是而然的性能提升. 然而继续会被聚焦,WASM 的另一个动机是希望为 Web 平台带来更多非 JS 语言的奇偶校验。例如,如果一个语言例如Go,其支持线程编程,但是JS语言不支持,WASM提供Go程序转换为JS引擎能理解的语言,不需要在JS语言自身需要线程功能.

换句话说,WASM减轻了向JS中添加功能的压力,这些特性主要是专门为从其他语言编译的程序使用的。这意味着 JS 功能开发可以被评判（通过 TC39），而不会被其他语言生态系统中的利益/需求所扭曲，同时仍然让这些语言有一条可行的路径进入 Web。

另一个在WASM上的视角是,和Web不直接相关.WASM正在进化为一个化平台虚拟机,程序可以被编译一次并且在不同系统环境中运行.

所以,WASM不知对web,并且WASM也不是JS.讽刺的是,即使WASM在JS引擎中运行,JS语言也是一种最合适追踪WASM程序的语言,因为WASM重度依赖静态输入信息. 即使TS, JS+静态类型,转为以WASM不是很合适,尽管不同的语言像AssemblyScript尝试在JS/TS和WASM弥补差距.

这本书不是关于WASM的,所以我不会话太多时间来讨论它,期待最后一点._一些_ 人认为 WASM 指出了 JS 从 Web 中删除或最小化的未来。这些人经常对 JS 怀有恶意，并希望用其他语言 — 任何其他语言 — 来取代它。由于 WASM 允许其他语言在 JS 引擎中运行，因此从表面上看，这并不完全是一个幻想的童话故事。

But let me just state simply: WASM will not replace JS. WASM significantly augments what the web (including JS) can accomplish. That's a great thing, entirely orthogonal to whether some people will use it as an escape hatch from having to write JS.
但是让我简单来说: WASM不会代替JS. WASM增大

## *Strict*ly Speaking

在2009年ES5发布之后, JS添加了严格模式作为一种选择加入机制，以鼓励更好的 JS 进程。

严格模式的好处超出成本,但是旧习惯很难消亡, 已经存在代码基很难避免. 所以很遗憾,至少十年以后, 非强制性的严格模式意味着对JS程序员来讲不是必要的.

为什么使用严格模式? 严格模式不应该在不能做方面视为限制,而是作为需要做什么的最佳指导,所以JS引擎拥有最好的时机来优化提升执行代码. 绝大多数JS代码对开发者团队有用,所以严格模式经常帮助代码合并,避免在非严格模式下拆分的问题错误.

大部分严格模式控制是以早期错误的形式,意味着不是严格语言错误也能在编译时(在代码执行前)抛出. 例如, 严格模式不允许命名两个相同的函数参数,所以结果尽可能早点报错.一些其它严格模式控制机制只在运行时观察,例如`this`默认指向`undefined`而不是全局对象.

与其挑战和抱怨严格模式,像一个只想挑战任何他们父母不让做的小孩,最好的心态是严格模式类似检查器, 来提醒你JS如何编写才会有高质量和机会来性能. 如果你发现自己被限制住了,努力围绕严格模式来工作,这应该是一个响亮的红色警告信号，您需要备份并重新考虑整个方法。

Strict mode is switched on per file with a special pragma (nothing allowed before it except comments/whitespace):
严格模式在每个文件中使用特殊编程(在它期望评论/空格之前不允许任何内容)来切换

```js
// only whitespace and comments are allowed
// before the use-strict pragma
"use strict";
// the rest of the file runs in strict mode
```

| WARNING:                                                                                                                                                                                                                                                                                             |
| :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Something to be aware of is that even a stray `;` all by itself appearing before the strict mode pragma will render the pragma useless; no errors are thrown because it's valid JS to have a string literal expression in a statement position, but it also will silently _not_ turn on strict mode! |

Strict mode can alternatively be turned on per-function scope, with exactly the same rules about its surroundings:

```js
function someOperations() {
    // whitespace and comments are fine here
    "use strict";

    // all this code will run in strict mode
}
```

有意思的是,如果文件开启了严格模式,函数级别的严格模式编译指示不被允许.所以你必须选择其中一个.

将每个函数的方法用于严格模式的 **唯一** 有效原因是，当你正在转换现有的非严格模式进程文档，并且需要随着时间的推移一点一点地进行更改时。否则，简单地为整个文档/进程打开严格模式要好得多。

很多人好奇如果当JS默认为严格模式会如何?答案是,肯定不会.当我们之前讨论向后兼容,如果JS引擎开始以严格模式建议代码编写,即使不必如此,它可能会因为严格模式而崩溃.

然而,有几个因素可以减少 Strict 模式的这种非默认 “模糊” 的未来影响。

一个是,几乎所有转译后的代码最终都处于 strict 模式，即使原始源代码不是这样编写的。生产中的大多数 JS 代码都已转译，因此这意味着大多数 JS 已经遵循 strict 模式。可以撤销这个假设，但你真的必须想尽办法这样做，所以这不太可能。

其它, 越来越多的/大多数新 JS 代码使用 ES6 模块格式编写，正在发生很大的转变。ES6 模块采用 strict 模式，因此此类文档中的所有代码都自动默认为 strict 模式。

综上所述，严格模式在很大程度上是事实上的默认值，尽管从技术上讲它实际上并不是默认值。

## Defined

JS is an implementation of the ECMAScript standard (version ES2019 as of this writing), which is guided by the TC39 committee and hosted by ECMA. It runs in browsers and other JS environments such as Node.js.

JS is a multi-paradigm language, meaning the syntax and capabilities allow a developer to mix and match (and bend and reshape!) concepts from various major paradigms, such as procedural, object-oriented (OO/classes), and functional (FP).

JS is a compiled language, meaning the tools (including the JS engine) process and verify a program (reporting any errors!) before it executes.

With our language now _defined_, let's start getting to know its ins and outs.

[^specapb]: ECMAScript 2019 Language Specification, Appendix B: Additional ECMAScript Features for Web Browsers, https://www.ecma-international.org/ecma-262/10.0/#sec-additional-ecmascript-features-for-web-browsers (latest as of time of this writing in January 2020)

### 注释

[什么是 smooshGate](https://tie.pub/2019/12/dont-break-the-web/)
